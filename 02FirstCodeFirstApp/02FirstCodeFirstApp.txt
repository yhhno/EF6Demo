01 创建控制台项目
  1.1新建控制台应用醒目
  1.2安装Entity Framework    Nuget 命令   Install-Package EntityFramework -Version 6.1.3

02根据Net中的类来创建数据库
 上面步骤之后，我们可以开始写代码了，在写代码之前，你要始终记得，每个类就是相应的数据表中的一行数据，该类的属性对应的的是这行数据的列。
  2.1创建EDM实体数据模型
	现在我们创建一个捐赠者类Donator
	我们需要定义和期望的数据库相匹配的属性， 类Nonator中，  Net中的int类型会映射到SQL Server中的int类型，String类型会映射到所有可能的字符类型，Decimal类型和Datetime也和SQL Server中的一样，
	大多时候，我们不需要关心这些细节，我们只需要编写能够表示数据的模型类就行了，然后使用标准的Net类型定义属性，其他的让EF自己计算出保存数据所需要的RDBMS类型
 2.2 创建数据库上下文
    接下来我们创建数据库上下文，它是数据库的抽象，
	目前，我们只有一张表Donator，因而要给数据库上下文定义一个属性来代表这张表，再者，一张表肯定不止一条数据行，所有我们必须定义一个集合属性，EF使用DbSet来实现这个目的

	再这里DbContext是所有基于EF的上下文的基类，通过它可以访问到数据库中的所有表，Context类继承DbContext类，在Context类中，调用了父类的构造函数，并且传入了一个键值对，键是name，值是FirstCodeFirstApp，这个键值对是定义在应用程序的配置文件中的，取决于你的应用程序类型，可能是app.config或者web.config。 在我们的控制台应用程序中就是app.config。

	在app.config文件的Configuration的节点下，添加数据库字符串

	接下来就是应该创建数据库了，创建数据库的方式有两种：
	  1.在后面的博客中我们会通过数据库迁移来实现数据库的创建，原理就是数据库会在第一次查询，更新或插入操作时创建
	  2.通过EF数据库的API来创建。

	我们先采用第二种方式来创建数据库， 首先我们必须确保数据库中没有和我们要创建的数据库同名的数据库存在，否则会提示错误，当然，我们也可以通过EF的API访问数据库来创建数据库。

	执行完成后，可以清楚地看到，数据库表名就是自定义数据库上下文的属性，而表中的列是数据模型的属性，此外，注意下列的类型，EF默认将DonatorIdzuo作为了主键（有疑问），string类型的Name在数据库中的类型是nvarchar(max),这些都是在使用EF时必须注意的命名规范（或者约定）

	问题：1 如果有同名数据库，没有任何操作，2如果删除了一张表，重写操作不会补上


	03简单的CRUD操作

      3.1创建记录--Create
	   你可以这样认为，将对象添加到集合中就相当于数据行插入到数据库的相应的表中，
	   我们使用DbSet的Add方法来实现新数据的添加，而DbContext类的SaveChanges方法会将未处理的更改提交到数据库，这是通过检测上下文中的所有的对象的状态来完成的。所有的对象都驻留在上下文类的DbSet属性中，
	   比如我们的例子，只有一个Donators属性，那么所有的捐赠人的数据都会存储到这个泛型集合属性中，数据库上下文会跟踪DbSet属性中的所有对象的状态，这些状态有这么几种：Deleted，Added，Modified和Unchanged，如果你想在一个表中插入多行数据，那么只需要添加该表 对应类 的多个对象的实例即可，然后就使用SaveChanges方法将更改提交到数据库，该方法是以单事务执行的。最终，所有的数据库更改都会以单个工作单元持久化，既然是事务的，那么这就允许将批量相关的更改作为单个操作提交，这样就保证了事务一致性和数据完整性。

	   这里需要注意两点：
	    1.不需要给DonatorId属性赋值，因为它对应到SQL Server表中的主键列，它的值是自动生成的，当SaveChanges执行之后，打个断点就能看到返回的DonatorId已经有值了。
		2.Context的实例用了using语句包装起来，这是因为DbContext实现了IDisposable接口，Dbcontext还包含了DbConnection的实例，该实例指向了具有特定连接字符串的数据库，在EF中合适地释放数据库连接和ADO.NET中同等重要。



		3.2查询记录---Retrieve
		查询时也是直接通过DbSet进行查询的。
		EF中很重要的概念：延迟查询， 但是此时还没有真正长训数据库，只有当LINQ的查询结果被访问或者枚举时才会将查询命令发送到数据库，EF是基于DaSet实现的IQueryable接口来处理延迟查询的

		物质化：Materialization   从数据库中读出数据，通过DbDataReader转换成Net对象的过程

		3.3 更新记录--Update
		在SQL中，更新需要使用Update命令，而在EF中，我们要找到DbSet集合中要更新的对象，然后更改其属性，最后调用SaveChanges方法即可。


		3.4 删除数据---Delete


	4数据库模式更改 介绍
	  如果你修改了Donator类，或者又添加了新的DbSet属性(即添加了新表)，在操作过程中你可能会遇到一些异常
	  现在我想再添加一张表PayWays，用来存储打赏者的打赏方式，比如微信，支付宝，qq红包等。

	  先定义两个字段，以后可能会增减字段和Donator表关联：

	  我们更改了数据库模式（即添加了新表），然后编译项目时，会报错，数据库和此时的上下文对应不上，

	  在后面我会介绍数据库迁移和对已存在的数据库进行迁移，但是我们现在也要解决这个当前问题，这就引入了初始化器（Initialize）的概念，
	  初始化器会在首次实例化过程期间或者EF首次访问数据库时运行，EF中需要关心的初始化器有三种
	    1.CreateDatabaseIfNotExists<TContext> 指如果数据库不存在则创建
		2.DropCreateDatabaseIfModeChanges<TContext> 如果模型改变了（包括模型类的更改以及上下文中集合属性的添加和移除），就销毁之前的数据库在创建数据库
		3.DropCreateDatabaseAlways<TContext> 总是销毁再重新创建数据库，如果没有指定的话，默认使用第一个初始化器，

	我们使用第二种初始化器
	要使用初始化器，我们应该在实例化数据库上下文之前就要让EF知道，我们可以使用EF的API总的Database类的SetInitialize静态方法
	在我们的控制台应用中，我们应该将它放在Main方法的第一行。

	数据库模式更改后，添加初始化器后，然后在运行项目，就不会报错了，而起数据库结构也发生变化了。（此时，数据库不能再其他的应用程序中打开，否则会抛出异常，会通知EF无法获得一个独占的锁以销毁数据库，此时只需要关闭其他程序就可以了）

	需要注意的是，因为使用的第二种初始化器，会销毁之前的数据库，因此之前积累的所有数据都丢失了，很显然，这种情况不适合生产环境，但是我们学习EF或者项目早期是很方便的，另一个有趣的功能是，初始化器允许我们在目标数据库创建之后运行其他代码，可以通过重写Seed方法即可，该方法需要一个数据库上下文的实例参数。、

	Seed方法不需要调用SaveChanges方法，此外，要更新生产数据库，我们可以使用EF Migrations 
	(ps。 Seed重写方法，在模型更改后，到修改后的对象被检索或访问时，之前执行)


	5本章小结
	我们创建了一个基于EF Code First的控制台应用程序，
	创建了一个Donator类映射到数据库中的Donators表，然后创建了数据库抽象Context类，它继承自DbContext，并在它的构造函数中指定了想要的连接字符串，同时把该字符创添加到应用的配置文件中。然后，我们给数据库上下文添加了一个属性Donators，它是Donator的集合,即DbSet，之后，让程序跑起来，然后我们发现数据库中产生了和该属性同名的数据表，数据库的创建过程使用了很多约定，包括表名和主键的确定。



