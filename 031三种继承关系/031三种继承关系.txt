031三种继承关系
  到目前为止，我们已经学会了如何使用EF的Code First将领域实体类映射到数据表，我们也学会了如何创建具有多样性关系的实体，以及如何使用EF将这些关系映射到数据库表之间的关系
  现在我们看一下领域实体间的继承关系，以及使用EF将这些数据映射到单独的表中，接下来会介绍下面的三种继承关系
    1.Table per Type(TPT) 继承
	2.Table per Class Hierarchy(TPH) 继承
	3.Table per Concrete Class （TPC） 继承

	1TPT继承 
	当领域实体类有继承关系时，TPT继承很有用，我们想把这些实体类模型存到数据库中，这样，每个领域实体都会映射到单独一个表中，这些表会使用一对一关系相互关联，数据库会通过一个共享的主键维护这个关系。
	假如有这么个场景：一个组织维护了在一个部门工作的所有人的数据库，这些人有些是拿着固定工资的员工，一些是按小时付费的供应商，要模型化这个场景，我们要创建三个领域实体，Person、Employee和Vendor。Person是基类，另外两个类从它继承
	在TPT继承中，我们想为每个领域实体类创建单独的一个表，这些表共享一个主键，因此生成的数据库就像下面这样。
    使用cd类图设计实体类，添加数据注解 （映射到数据库）
	对于Person类，我们使用EF的默认约定来映射到数据库，而对Employee和Vendor类，我们使用了数据注解，将它们映射为我们想要的表名。

	然后添加数据库上下文  集合属性 链接字符串

	最后看生成的数据库， 我们看到每个表都包含单独的数据，这些表之间都有一个共享的主键，因而这些表之间都是一对一关系

	2TPH继承
	当领域实体有继承关系，但是我们想将 来自所有实体类的数据保存到单独的一个表中时，TPH继承很有用，从领域实体的角度，我们的模型类的继承关系仍然像上面的类图一样。person为基类  Employee类和Vendor类继承

	但是从数据库角度，应该只有一张表，因此，最终生成的数据库的样子应该是下面这样的。

	此时，我们无论我们创建任何一个子类类型，公共的字段都会填充，如果子类类型为Employee类型，那么除了公共字段外，Salary还会包含值，但是HourlyRate字段就会是null，如果该子类类型是Vendor类型，那么hourlyRate会包含值，Salary会是null
	ps.从数据库的角度来看，这种模式很不优雅，因为我们将无关的数据保存到了单张表中，如果我们使用这种方法，那么总会存在一些包含null值的冗余列

	现在我们现在创建实体类来实现该继承，注意，这次创建的三个实体类和之前创建的知识没有类上的数据注解，这样它们就会映射到数据库中的单张表中（EF默认使用父类的DbSet属性名，或其复数形式作为表名），并且将派生类的属性映射到那张表中.

	如果你细心，你会发现生成的表中多个了的字段Descriminator，它是用来找到记录的实际类型，即从Person表中找到Employee或者Vendor。

	因此，如果我们没有在具有继承关系的实体之间提供确切的配置，那么EF会默认将其对待成TPH继承，并把数据放在单张表中。

	

	3TPC继承
	当多个领域实体派生自一个基实体，并且我们想将所有具体类的数据分别保存在各自的表中，以及抽象基类实体在数据库中没有对应的表时，使用TPC继承。
	从领域实体的角度看，我们仍然想要模型维护该继承关系，因此，实体模型和之前的一样。见TPT继承类图

	然而，从数据库的角度看，只有所有具体类所对应的表，而没有抽象类对应的表，
	这种数据库设计的最大问题之一就是数据表中列的重复问题，从数据库标准的角度 这是不推荐的

	现在创建领域实体类，这里Person类应该是抽象的，其他都一样

	接下来配置数据库上下文，如果我们只在数据库上下文中添加了Person的DbSet泛型属性集合，那么EF会当做TPH继承处理，那么还需要使用Fluent API来配置映射（当然你可以使用配置伙伴类）

	在Fluent API中，MapInheritedProperties方法将继承的属性映射到表中，然后我们根据不同的对象类型映射到不同的表中。

	执行成功后，虽然数据插入到数据库中了，但是运行程序时出错了，出现该异常的原因是EF尝试去访问抽象类中的值，它会找到两个具有相同Id的记录，然而Id列被识别为主键，因而具有相同主键的两条记录就会产生问题，这个异常清除地表明了存储或数据库生成的Id类对TPC继承无效


	如果我们想使用TPC继承，那么要么使用基于GUID的Id,要么从应用程序中出入Id，或者使用能够维护对多张表自动生成的唯一性的某些数据库机制



	本章小结：
	这篇博客中，我们看到了如何使用EF Code First方法在应用程序中使用领域实体，以及如何持久化数据到数据库，也看了如何管理实体间的多样性关系，以及使用EF将这些关系映射到数据库，最后我们看了如何使用EF来管理涉及继承关系的实体，看到了，三种继承关系对应三种不同的数据库模式





