01 理解Code First及其约定和配置
1.1深入理解Code First

 传统设计应用的方式都是由下而上的，即我们习惯先考虑数据库，然后使用这个以数据为中心的方法来在数据之上构建应用程序，这种方法非常适合于数据密集的应用或数据库很可能包含多个应用使用的业务逻辑的应用，对于这种应用，如果要使用EF的话，我们必须使用Database First方式。

设计应用的另一种方式就是以领域为中心的方式（领域驱动设计DDD），DDD是一种由上而下的方式，我们通过从实现应用所需要的领域模型和实体的角度思考，从而开始设计应用，数据库很少用来用于领域模型数据的持久化，使用DDD意味着我们要根据每个应用的需求来设计模型和实体，而且模型和实体是数据库可忽略的，即可使用任何数据库技术实现保存，在这些情景中，我们应该使用EF的Code First方式，因为它允许我们创建POCOs（Plain Old CLR Objects）作为持久化可忽略的领域模型
  使用EF code first的优势在于：
    1.支持DDD
	2.可以早早地着手开发，因为我们不必等待数据库的创建
	3.持久化层（底层的数据库）的改变 不会对现有的模型有任何影响

1.2理解Code First的约定和配置
 我们需要搞清楚的第一件事就是约定大于配置的概念，Code First方式期望模型类遵守一些约定，这样的话数据库持久化逻辑就可以从模型中提取出来，比如，如果我们给一个模型定义了一个Id属性，那么它就会映射到数据库中该类所对应的那张表的主键，这种基于约定的方式的好处在于，如果我们遵守了约定，那么我们就不必写额外的代码来管理数据库持久逻辑，缺点在于，如果没有遵守那个约定，那么EF就不会从模型中提取到需要的信息，运行时会抛异常，

 在这种没有遵守约定又要持久化数据的情况下，我们需要使用Code First的配置项提供关于模型的一些额外的信息，比如，如果我们的模型类中没有Id属性作为主键，那么我们需要在想要的属性上加上【Key】特性，这样它就会被当做主键了。

 EF使用模型类的复数的约定来创建数据库表名，创建的列名和该类的属性名是一样的。

 02创建数据库结构
   2.1Net类型和SQL类型之间的映射。
  首先第一篇就睡哦了，EF这个ORM工具就是用来解决NET类型和SQL Server列类型之间的阻抗失配的问题，比如，假如你在NET中定义了一个int类型的属性，那么就可以认为EF已经安全地处理这个列的定义并使用了合适的类型与之应对，记住一些NET类型和SQL Server列类型之间的映射是很重要的，完成的映射列表参考MSDN，如果你使用的是其他类型的数据库，可以上网查找

  2.2配置原始属性
  就以Net中的string类型的属性开始讨论吧，SQL Server中的很多类型都会映射到NET中的string类型，其他主流的RDBMS也是一样的，因此，决定如何存储字符串类型的信息是很重要的，很多关系型数据库管理引擎都有多个字符存储类型，他们通常都有以字母N打头的字符类型，这个字母表示要存在这些列中的数据时Unicode数据，基于每个字符以2个字节的格式存储，因此，如果你的数据库中列存储的是英文的话，就可以使用varchar或者char（可能会加速查询），如果使用的是中文的话，就要使用nvarchar或者nchar，此外，还可以使用带有var的字符类型来指定列的长度是可变的，，不使用var的话，字符长度是不可变的。

  在EF中，有以下几种配置数据库结构的方式，分别是：
   1.特性，也叫数据注解
   2.DbModelBuilder API
   3.配置伙伴类
 2.2.1 特性【数据注解】
  这些特性类都是NET的一部分，位于System.ComponetModel.DataAnnotations命名空间，下面我们修改之前的代码

  修改之后，我们将表的名字使用Table特性全部重新命名为了单数，将Donator的主键通过Column特性更改了为Id，Key特性指定它是主键，还通过StringLength制定了Donator的名字最长为10个字符，最少为2个字符，
  使用了特性后，生成的数据库与默认约定生成有了不同

  下面是常用的用于重写默认的约定的特性，使用这些特性可以更改数据库模式：
   1.Table：指定该类要映射到数据库中的表名
   2.Column：指定类的属性要映射到数据表中的列名
   3.Key：指定该属性是否以主键对待
   4.TimeStamp：将该属性标记为数据库中的时间戳列
   5.ForeignKey：制定一个导航属性的外键属性
   6.NotMapped：指定该属性不应该映射到数据库中的任何列
   7.DatabaseGenerated：指定属性应该映射到数据表中的计算的列，也可以用于映射到自定增长的数据库表
此外，数据注解也用作验证特性，如果持久化数据时，模型对象的属性值和数据注解所标记的不一致，就会抛出异常，例如上面的PayWay类的Name属性，ErrorMessage的值就是发生异常时抛出的信息。
 
 2.2.2 Fluent API
  DbContext类有一个OnModelCreating方法，它用于流利地配置领域类到数据库模式的映射，下面我们以Fluent API的方式来定义映射。
  首先，先将Donator类注释掉，重新编写该类
  然后在数据库上下文中的OnModelCreating方法中使用Fluent API来定义Donator表的数据库模式：

  modelBuilder.Entity<Donator>() 会得到EntityTypeConfiguration类的一个实例，此外，使用Fluent API的一个重要决定因素是我们是否使用了外部的POCO类（）即实体模型类是否来自一个类库），我们无法修改类库中的类的定义，所以不能通过数据注解来提供映射细节，这种情况，我们必须使用Fluent Api

  生成后的数据库，Donator又变成复数了e

  2.2.3  每一个实体类配置一个伙伴类
  不知道你有没有注意个问题？  上面的OnModelCreating方法中，，我们只配置了一个类Donator,也许代码不是很多，但也不算很少，如果我们有1000个类怎么办？都写在一个方法中肯定不好维护？ EF提供了另一种方式来解决这个问题，那就是为每个实体类单独创建一个配置类，然后再在OnModelCreating方法中调用这些配合伙伴类。

  先创建Donator的配置伙伴类：DonatorMap
  
  然后在数据库上下文中调用 DonatorMap即可,《要设置主键》
这种写法和使用ModelBuilder是几乎一样的，只不过这种方法更好组织处理多个实体，你可以看到上面的语法和写JQuery的链式编程一样，这种方法的链式写法叫做Fluent API。

 2.3 处理可空（nullable）属性
 有些列是可空的，有些不可空，EF会通过约定来决定一列是否是nullable,比如，string类型允许空值，因此匹配的基于字符的列就是nullable，另一方面，datetime和int变量在NET中是不能为null的，所以这些列是non-nullable。如果我们想让这些列是nullable或者想使得字符串存储列 强制有值，该怎么办呢？

 方法一：直接使用可空类型对实体类的属性进行定义，这是目前最简单的方法，例如，如果上面的打赏日期允许空值的话，那么应该这样定义：public DateTime? Donator{get;set;}
 方法二：如果Donator的名字不可为空，那么我们可以像上面的配置类中那样写，使用IsRequired（）方法，相对应地，IsOptional（）方法就是允许为空值。

 需要格外注意的是： 如果你使用的是其他数据库，NET中的某些类型可能不能正确地映射到这些数据库系统 ，解决方案就是在属性配置类中使用HasColumnType方法，然后指定你想要显式使用的名字。如果你想支持多个数据库引擎，那么只要写一个helper类就可以解决了，该helper类会基于当前配置的数据库引擎以字符串的形式返回正确的数据库类型，所有的原始属性配置类共享两个方法，HasColumnName和HasColumnOrder..HasColumnName 允许我们可以创建不同于属性名称的列名，如果你想定义成一样的，那么就不需要该方法了，HasColumnOrder可以让我们精确地控制列在表中的排列位置。

 

 03管理实体关系
  我们现在已经知道如果使用Code First来定义简单的领域类，并且如何使用DbContext类来执行数据库操作，现在我们来看下数据库理论中的多样性关系，我们会使用Code First来实现下面的几种关系
    1.一对多关系
	2.一对一关系
	3.多对多关系
首先我们要明确关系的概念，关系就是定义两个或多个对象之间是如何关联的，它是由关系两端多样性值识别的，比如一对多意味着在关系的一端，只有一个实体，我们有时称为父母；在关系的另一端，可能有多个实体，有时成为孩子，EF API将那些端分别称为主体和依赖，一对多个关系也叫作一或零对多（One-or-Zero-to-Many），这意味着一个孩子可能有或可能没有父母，一对一关系也稍微有些变化，就是关系的两端都是可选的


3.1 一对多关系
 如果要在数据库中配置一对多关系，我们可以依赖EF约定，或者可以使用数据注解/Fluent API来显示创建关系，接下来还是使用捐赠者Donator和支付方法PayWay这两个类来举例子，这里的一对多关系是：一个人可以通过多个支付方式赞助我
  
	支付方式PayWay类采用数据注解方式定义 Version4

	因为一个赞助者可以通过多个支付方式赞助我，这句话就表明了Donator对象应该有一个PayWay的集合，因此，我们要给Donator类新加一个属性，Donator类采用配置伙伴类的方式定义如下：

	为了潜在的null引用异常可能性，当Donator对象创建的时候，我们使用HashSet的T集合类型实例创建一个新的集合实例，如下所示：
	你可能注意到当我定义PayWays属性时使用了virtual关键字，当为一个赞助者查询他的支付方式时，该关键字允许我们使用懒加载（Lazy Loading），也就是说当你尝试访问Donator的PayWays属性时，EF会动态地从数据库加载PayWays对象到集合中，懒加载，顾名思义，就是首次不会执行查询来填充PayWays属性，而是在请求它的时才会加载数据，
	还有另一加载相关数据的方式叫做预先加载（eager loading），通过预先加载，在访问PayWays属性之前，PayWays就会主动加载，
	现在我们假设要充分使用懒加载功能，所以这里使用了Virtual关键字，这里有意思的是，在支付方法PayWay类中并没有包含Donator的Id属性，这是作为数据库开发者必须要做的一些事，但在EF的世界中，我们有很大的灵活性来忽略这个属性，由于当我们看支付方式的时候可能没有合理的业务原因来知道该赞助者的Id，所以我们可以忽略该属性。 这个例子中，我们只想在Donator的上下文中了解他的支付方式，并不把它们分离开作为独立对象，现在我们假设这能正确运行，然后添加一个网名为：新的捐赠者的捐赠者，因为他的支付宝和微信都打赏过了，代码如下

	此时，代码中，我们添加了一个赞助者，然后给该对象的PayWays属性追加两个元素，最后批量保存它们，注释掉初始化器中的种子数据，然后运行应用，

	我们只编写了OOP代码：创建了一个类的实例，然后将PayWay类的实例添加到一个集合。EF的很多默认约定可以帮我们创建正确的数据库结构，包括将对象操作转成数据库查询，从上面的操作来看，在PayWays表中，EF使用默认的约定帮我们自动创建了一个Donator_Id的列作为外键，当然，你完全可以通过代码手动修改这个外键的名字，比如要将Donator_Id修改为DonatorId,只需要在PayWays类中添加一个属性DonatorId(该属性名称是我们想要的列名)，然后，我们需要配置Donator对象，告诉它有多个支付方式，每一个支付方式都会通过DonatorId属性链接到一个Donator，然后给Donator配置伙伴类DoantorMap追加代码如下：
	HasMany(d=>d.PayWays).WithRequired().HasForeignKey（p=>p.DonatorId);
	上面的代码对于关系的定义很经典，HasMany方法告诉EFDonator和PayWay类之间有一个一对多的关系，WithRequired方法表明链接在PayWays属性上的 Donator是必须的，换言之，PayWay对象不是独立的对象，必须要链接到一个Donator,HasForeighKey方法会识别哪一个属性会作为链接。

	3.1.2 另一个用例
	接下来在看另一个例子，这个用例出现在当主要实体上有一个查询属性，且该查询属性指向另一个实体时，查询属性指向一个完整的子实体的父亲，当操作或检查一个子记录需要访问父信息时，这些属性很重要，，比如，我们再创建一个类DonatorType（该类用来表示赞助者的类型，比如有博客园园友和非博客园园友），然后给Donator类添加DonatorType属性，本质上，这个例子还是一个一对多的关系，但是方法有些不同，这种情况下，我们一般会在主实体的编辑页面使用一个包含查询父表值的下拉控件，我们的查询父表很简单，只有Id和Name列，我们将使该关系为可选的，以描述如何添加可空的外键，因此，Donator类中的DonatorType必须是可空的，
	定义新的Donator类：添加可空的DonatorTypeId属性和DonatorType类型的属性

	反过来，我们要在DonatorType类中的添加一个集合属性，表示每种赞助者类型有很多赞助者，

	提起关系，我们可以在关系的任何一端（主体端或依赖端）进行配置， 下面，我们创建一个新的DonatorTypeMap伙伴类以达到目的，
	添加DonatorTypeMap类,DonatorTypeMap类中的WithOptional方法表示外键约束可为空，使用WillCascadeOnDelete方法可以指定约束的删除规则，
	对于外键关系约束，大多数数据库引擎都支持删除规则的多操作，这些规则指定了当一个父亲删除之后会发生什么，将外键列设置为null之后，如果孩子不存在，或者删除了所有相关的依赖都会报错，EF允许开发者要么删除所有的孩子行，要么啥也别做。一些数据库管理员反对级联删除，因为一些数据库引擎没有提供级联删除时的充足的日志信息

	不要忘了在Context类中添加DonatorType的DbSet，还有在model builder上添加DonatorTypeMap的配置类，调用WillCascadeOnDelete的另一种选择是，从model builder中移除全局的约定，在数据库上下文的OnModelCreating方法中关闭真个数据库模型的级联删除规则，

	3.2 一对一关系
	一对一关系并不常见，但是偶尔也会出现，如果一个实体有一些可选的数据，那么可以选择这种设计，
	下图中的两张表的主键是一 一对应的

	比如我们创建两个实体类Person和Student，一个人可以是个具有注册日期的大学生，对于那些不是大学生的人来说，大学和注册日期就是可空的，因此，我们会将这些数据组合到一个新的实体Student中。

	使用了HasKey方法，制定了一个表的主键，换而言之，这是一个允许我们找到一个实体的独一无二的值，之前我们没有用这个方法是因为我们要么用了Key特性或者遵守了EF的默认约定（如果属性名是由类名+Id或者只是Id组成，那么EF会计算出该主键）。因为我们现实使用了PersonId作为主键，所以我们现在需要给运行时提供额外的提示，这就是HasKey排上用场的地方，最有子表中的主键会成为父表中的外键。

	因为该关系是可选的所以它也称为一或者零对一（One-or-Zero-To-One），关系的两端都是必须要存在的关系成为一对一，比如，每个人必须要有一个单独的login，这是强制的，你也可以使用WithRequiredDepentent或者WithRequiredPrincipal方法代替WithOptional方法

	我们可以总是从该关系的主体端或者依赖端来配置关系，我们总是需要配置一对一关系的两端（即两个实体）使用Has和With方法确保一对一关系的创建


	3.3 多对多关系
	当关系的两端都有多个实体时，我们就应该考虑使用多对多（Many-to-Many）关系了，比如每个人可以为多个公司干活，每个公司可以雇佣多个人，在数据层，这种关系是通过所谓的连接表（junction table）定义的，有时也叫交叉引用表，这个表会包含该关系两端表的主键列，这种类型的关系有两种用例对我们来说很重要，一个连接表可以没有额外的数据或者列，或者它可以有额外的数据，如果连接表没有其他的数据，那么从技术上讲，我们根本不需要创建表示这个连接表的模型

	下面就让我们对这种情况进行编码，创建新的模型类Company类，Person类是在之前的基础上添加属性，然后修改PersonMap伙伴类来表示两个实体间的关系，就像一对多关系一样，我们会在Person和Company类中添加相关类的集合

	技术上来讲，如果你对EF生成列名的约定没问题的话，那么该配置是可省略的，意思就是说，EF实际上会根据该关系两端定义的类和属性独立地创建一个连接表，因为相关的实体有集合属性，如果我们想要不同于默认创建的表名或列名，就可以在连接表中显式指定表名或列名

	可以看到EF自动帮我们生成了PersonCompanies，当然我们也可以在PersonMap伙伴类中自定义，只需要添加m.ToTable（“PersonCompany”），即可。

	如果我们连接表需要保存更多的数据怎么办？ 比如当每个人开始为公司干活时，我们想为他添加雇用日期，这样的话，实际上我们需要创建一个类来模型化该连接表， 我们暂且称为PersonCompany吧，它仍然具有两个的主键属性，PersonId和CompanyId，它还有Person和Company的属性以及雇佣日期的属性。 此外，Person和Company类分别都有PersonCompanys的集合属性而不是单独的Person和Company集合属性。

